<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprint 3. Lesson 31</title>
    <link rel="stylesheet" type="text/css" href="../../../css/pages_style.css">
    <link rel="stylesheet" href="../../../bootstrap-5.1.3-dist/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="css/lesson_css.css">
    <script type="text/javascript" src="../../../js/menu.js"></script>
</head>
<body>
    <div id="lesson_menu_bootsrap"></div>
    <div class="header">
        <div class="header-inner">
            <h1 id="l31_p0">Lesson 31: JS. Basic operators.</h1>
        </div>
    </div>
    <a href="#l31_p0" class="move_up_arrow"></a>
    <div class="container">
        <div class="inner_content">
            <h4>Содержание:</h4>
            <ul>
                <li><a href="#l31_p1">Базовые операторы, математика</a></li>
                <li><a href="#l31_p2">Термины: «унарный», «бинарный», «операнд»</a></li>
                <li><a href="#l31_p3">Математика</a></li>
                <li><a href="#l31_p4">Взятие остатка %</a></li>
                <li><a href="#l31_p5">Возведение в степень **</a></li>
                <li><a href="#l31_p6">Сложение строк при помощи бинарного +</a></li>
                <li><a href="#l31_p7">Приведение к числу, унарный +</a></li>
                <li><a href="#l31_p8">Приоритет операторов</a></li>
                <li><a href="#l31_p9">Присваивание</a></li>
                <li><a href="#l31_p10">Присваивание = возвращает значение</a></li>
                <li><a href="#l31_p11">Присваивание по цепочке</a></li>
                <li><a href="#l31_p12">Сокращённая арифметика с присваиванием</a></li>
                <li><a href="#l31_p13">Инкремент/декремент</a></li>
                <li><a href="#l31_p14">Побитовые операторы</a></li>
                <li><a href="#l31_p15">Оператор «запятая»</a></li>
            </ul>
            <hr>
            <h3 id="l31_p1">Базовые операторы, математика</h3>
            <p>
                Многие операторы знакомы нам ещё со школы: сложение +, умножение *, вычитание - и так далее. <br>
                В этой главе мы начнём с простых операторов, а потом сконцентрируемся на специфических для JavaScript аспектах, 
                которые не проходят в школьном курсе арифметики.
            </p>
            <hr>
            <h3 id="l31_p2">Термины: «унарный», «бинарный», «операнд»</h3>
            <p>
                Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией. <br>
                Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: 
                левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов». <br><br>
                Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" 
                меняет знак числа на противоположный:
                <pre class="code">
                    
                    let x = 1;

                    x = -x;
                    alert( x ); // -1, применили унарный минус
                </pre>
                Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной форме:
                <pre class="code">

                    let x = 1, y = 3;
                    alert( y - x ); // 2, бинарный минус вычитает значения
                </pre>
                Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания 
                (унарный оператор, который обращает знак) и оператор вычитания (бинарный оператор, который вычитает одно число из другого).
            </p>
            <hr>
            <h3 id="l31_p3">Математика</h3>
            <p>
                Поддерживаются следующие математические операторы:
                <ul>
                    <li>Сложение +,</li>
                    <li>Вычитание -,</li>
                    <li>Умножение *,</li>
                    <li>Деление /,</li>
                    <li>Взятие остатка от деления %,</li>
                    <li>Возведение в степень **.</li>
                </ul>
                Первые четыре оператора очевидны, а про % и ** стоит сказать несколько слов.
            </p>
            <hr>
            <h3 id="l31_p4">Взятие остатка %</h3>
            <p>
                Оператор взятия остатка <b>%</b>, несмотря на обозначение, никакого отношения к процентам не имеет. <br>
                Результат <b>a % b</b> – это остаток от целочисленного деления <b>a на b</b>. <br><br>
                Например:
                <pre class="code">

                    alert( 5 % 2 ); // 1, остаток от деления 5 на 2
                    alert( 8 % 3 ); // 2, остаток от деления 8 на 3
                </pre>
            </p>
            <hr>
            <h3 id="l31_p5">Возведение в степень **</h3>
            <p>
                В выражении a ** b оператор возведения в степень умножает a на само себя b раз. <br>
                Например:
                <pre class="code">

                    alert( 2 ** 2 ); // 4  (2 умножено на себя 2 раза)
                    alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
                    alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)
                </pre>
                Математически, оператор работает и для нецелых чисел. Например, квадратный корень является возведением в степень 1/2:
                <pre class="code">

                    alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
                    alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)
                </pre>
            </p>
            <hr>
            <h3 id="l31_p6">Сложение строк при помощи бинарного +</h3>
            <p>
                Давайте рассмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной арифметики. <br>
                Обычно при помощи плюса '+' складывают числа. <br>
                Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну:
                <pre class="code">

                    let s = "моя" + "строка";
                    alert(s); // моястрока
                </pre>
                Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку. <br>
                Например:
                <pre class="code">
                    
                    alert( '1' + 2 ); // "12"
                    alert( 2 + '1' ); // "21"
                </pre>
                Как видите, не важно, первый или второй операнд является строкой. <br>
                Вот пример посложнее:
                <pre class="code">

                    alert(2 + 2 + '1' ); // будет "41", а не "221"
                </pre>
                Здесь операторы работают один за другим. Первый + складывает два числа и возвращает 4, затем следующий + объединяет 
                результат со строкой, производя действие 4 + '1' = 41. <br>
                Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают только с 
                числами и всегда преобразуют операнды в числа. <br>
                Например, вычитание и деление:
                <pre class="code">
                    
                    alert( 6 - '2' ); // 4, '2' приводится к числу
                    alert( '6' / '2' ); // 3, оба операнда приводятся к числам
                </pre>
            </p>
            <hr>
            <h3 id="l31_p7">Приведение к числу, унарный +</h3>
            <p>
                Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной. <br>
                Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс 
                преобразует его в число. <br>
                Например:
                <pre class="code">
                    
                    // Не влияет на числа
                    let x = 1;
                    alert( +x ); // 1

                    let y = -2;
                    alert( +y ); // -2

                    // Преобразует не числа в числа
                    alert( +true ); // 1
                    alert( +"" );   // 0
                </pre>
                На самом деле это то же самое, что и Number(...), только короче. <br>
                Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. 
                А что, если их нужно, к примеру, сложить? <br>
                Бинарный плюс сложит их как строки:
                <pre class="code">
                    
                    let apples = "2";
                    let oranges = "3";

                    alert( apples + oranges ); // "23", так как бинарный плюс объединяет строки
                </pre>
                Поэтому используем унарный плюс, чтобы преобразовать к числу:
                <pre class="code">

                    let apples = "2";
                    let oranges = "3";

                    // оба операнда предварительно преобразованы в числа
                    alert( +apples + +oranges ); // 5

                    // более длинный вариант
                    // alert( Number(apples) + Number(oranges) ); // 5
                </pre>
                С точки зрения математика, такое изобилие плюсов выглядит странным. Но с точки зрения программиста тут нет ничего особенного: 
                сначала выполнятся унарные плюсы, которые приведут строки к числам, а затем бинарный '+' их сложит. <br>
                Почему унарные плюсы выполнились до бинарного сложения? Как мы сейчас увидим, дело в их приоритете.
            </p>
            <hr>
            <h3 id="l31_p8">Приоритет операторов</h3>
            <p>
                В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, 
                или, другими словами, существует определённый порядок выполнения операторов. <br>
                Из школы мы знаем, что умножение в выражении 1 + 2 * 2 выполнится раньше сложения. Это как раз и есть «приоритет». 
                Говорят, что умножение имеет более высокий приоритет, чем сложение. <br>
                Скобки важнее, чем приоритет, так что, если мы не удовлетворены порядком по умолчанию, мы можем использовать их, 
                чтобы изменить приоритет. Например, написать (1 + 2) * 2. <br>
                В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – 
                выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо. <br>
                Отрывок из таблицы приоритетов (нет необходимости всё запоминать, обратите внимание, что приоритет унарных операторов 
                выше, чем соответствующих бинарных): <br>
                Так как «унарный плюс» имеет приоритет 17, который выше, чем 13 у «сложения» (бинарный плюс), то в выражении 
                "+apples + +oranges" сначала выполнятся унарные плюсы, а затем сложение.
            </p>
            <hr>
            <h3 id="l31_p9">Присваивание</h3>
            <p>
                Давайте отметим, что в таблице приоритетов также есть оператор присваивания =. У него один из самых низких приоритетов: 3. <br>
                Именно поэтому, когда переменной что-либо присваивают, например, x = 2 * 2 + 1, то сначала выполнится арифметика, а уже затем 
                произойдёт присваивание = с сохранением результата в x.
                <pre class="code">

                    let x = 2 * 2 + 1;

                    alert( x ); // 5
                </pre>
            </p>
            <hr>
            <h3 id="l31_p10">Присваивание = возвращает значение</h3>
            <p>
                Тот факт, что = является оператором, а не «магической» конструкцией языка, имеет интересные последствия. <br>
                Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение + или умножение *. 
                Но и оператор присваивания не является исключением. <br>
                Вызов <b>x = value</b> записывает <b>value в x</b> и возвращает его. <br>
                Благодаря этому присваивание можно использовать как часть более сложного выражения:
                <pre class="code">

                    let a = 1;
                    let b = 2;

                    let c = 3 - (a = b + 1);

                    alert( a ); // 3
                    alert( c ); // 0
                </pre>
                В примере выше результатом (a = b + 1) будет значение, которое присваивается переменной a (то есть 3). 
                Потом оно используется для дальнейших вычислений. <br>
                Забавное применение присваивания, не так ли? Нам нужно понимать, как это работает, потому что иногда это 
                можно увидеть в JavaScript-библиотеках. <br>
                Однако писать самим в таком стиле не рекомендуется. Такие трюки не сделают ваш код более понятным или читабельным.
            </p>
            <hr>
            <h3 id="l31_p11">Присваивание по цепочке</h3>
            <p>
                Рассмотрим ещё одну интересную возможность: цепочку присваиваний.
                <pre class="code">

                    let a, b, c;

                    a = b = c = 2 + 2;

                    alert( a ); // 4
                    alert( b ); // 4
                    alert( c ); // 4
                </pre>
                Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение 2 + 2, и затем результат присваивается 
                переменным слева: c, b и a. В конце у всех переменных будет одно значение. <br>
                Опять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:
                <pre class="code">

                    c = 2 + 2;
                    b = c;
                    a = c;
                </pre>
                Польза от такого стиля особенно ощущается при быстром просмотре кода.
            </p>
            <hr>
            <h3 id="l31_p12">Сокращённая арифметика с присваиванием</h3>
            <p>
                Часто нужно применить оператор к переменной и сохранить результат в ней же. <br>
                Например:
                <pre class="code">

                    let n = 2;
                    n = n + 5;
                    n = n * 2;
                </pre>
                Эту запись можно укоротить при помощи совмещённых операторов += и *=:
                <pre class="code">

                    let n = 2;
                    n += 5; // теперь n = 7 (работает как n = n + 5)
                    n *= 2; // теперь n = 14 (работает как n = n * 2)

                    alert( n ); // 14
                </pre>
                Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -= и так далее. <br>
                Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после 
                большинства других операций:
                <pre class="code">

                    let n = 2;

                    n *= 3 + 5;

                    alert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)
                </pre>
            </p>
            <hr>
            <h3 id="l31_p13">Инкремент/декремент</h3>
            <p>
                Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу. <br>
                Для этого существуют даже специальные операторы:
                <ul>
                    <li>
                        Инкремент ++ увеличивает переменную на 1:
                        <pre class="code">

            let counter = 2;
            counter++;        // работает как counter = counter + 1, просто запись короче
            alert( counter ); // 3
                        </pre>
                    </li>
                    <li>
                        Декремент -- уменьшает переменную на 1:
                        <pre class="code">
            let counter = 2;
            counter--;        // работает как counter = counter - 1, просто запись короче
            alert( counter ); // 1
                        </pre>
                    </li>
                </ul>
                <b>Важно:</b> <br>
                Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке. <br>
                Операторы ++ и -- могут быть расположены не только после, но и до переменной.
                <ul>
                    <li>Когда оператор идёт после переменной — это «постфиксная форма»: counter++.</li>
                    <li>«Префиксная форма» — это когда оператор идёт перед переменной: ++counter.</li>
                </ul>
                Обе эти инструкции делают одно и то же: увеличивают counter на 1. <br>
                Есть ли разница между ними? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают ++/--. <br>
                Давайте проясним этот момент. Как мы знаем, все операторы возвращают значение. Операторы инкремента/декремента не исключение. Префиксная 
                форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа). <br>
                Чтобы увидеть разницу, вот небольшой пример: <br>
                <pre class="code">

                    let counter = 1;
                    let a = ++counter; // (*)

                    alert(a); // 2
                </pre>
                В строке (*) префиксная форма ++counter увеличивает counter и возвращает новое значение 2. Так что alert покажет 2. <br>
                Теперь посмотрим на постфиксную форму:
                <pre class="code">

                    let counter = 1;
                    let a = counter++; // (*) меняем ++counter на counter++

                    alert(a); // 1
                </pre>
                В строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1. <br>
                Подведём итоги:
                <ul>
                    <li>
                        Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать:
                        <pre class="code">

            let counter = 0;
            counter++;
            ++counter;
            alert( counter ); // 2, обе строки сделали одно и то же
                        </pre>
                    </li>
                    <li>
                        Если хочется тут же использовать результат, то нужна префиксная форма:
                        <pre class="code">

            let counter = 0;
            alert( ++counter ); // 1
                        </pre>
                    </li>
                    <li>
                        Если нужно увеличить и при этом получить значение переменной до увеличения – нужна постфиксная форма:
                        <pre class="code">

            let counter = 0;
            alert( counter++ ); // 0
                        </pre>
                    </li>
                </ul>
                Инкремент/декремент можно использовать в любых выражениях <br>
                Операторы ++/-- могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций. <br>
                Например:
                <pre class="code">
                    
                    let counter = 1;
                    alert( 2 * ++counter ); // 4
                </pre>
                Сравните с:
                <pre class="code">

                    let counter = 1;
                    alert( 2 * counter++ ); // 2, потому что counter++ возвращает "старое" значение
                </pre>
                Хотя технически здесь всё в порядке, такая запись обычно делает код менее читабельным. Одна строка выполняет множество действий – нехорошо. <br>
                При беглом чтении кода можно с лёгкостью пропустить такой counter++, и будет неочевидно, что переменная увеличивается. <br>
                Лучше использовать стиль «одна строка – одно действие»:
                <pre class="code">

                    let counter = 1;
                    alert( 2 * counter );
                    counter++;
                </pre>
            </p>
            <hr>
            <h3 id="l31_p14">Побитовые операторы</h3>
            <p>
                Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления. <br>
                Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования. <br>
                Поддерживаются следующие побитовые операторы:
                <ul>
                    <li>AND(и) ( <b>&</b> )</li>
                    <li>OR(или) ( <b>|</b> )</li>
                    <li>XOR(побитовое исключающее или) ( <b>^</b> )</li>
                    <li>NOT(не) ( <b>~</b> )</li>
                    <li>LEFT SHIFT(левый сдвиг) ( <b>&lt;&lt;</b> )</li>
                    <li>RIGHT SHIFT(правый сдвиг) ( <b>>></b> )</li>
                    <li>ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( <b>>>></b> )</li>
                </ul>
                Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. 
                В ближайшем времени они нам не понадобятся, так как веб-разработчики редко к ним прибегают, хотя в некоторых сферах (например, в криптографии) 
                они полезны. Можете прочитать 
                <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Expressions_and_Operators#%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D1%8B%D0%B5_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B">раздел о них на MDN</a>
                , когда возникнет реальная необходимость.
            </p>
            <hr>
            <h3 id="l31_p15">Оператор «запятая»</h3>
            <p>
                Оператор «запятая» (,) редко применяется и является одним из самых необычных. Иногда он используется для написания более короткого кода, 
                поэтому нам нужно знать его, чтобы понимать, что при этом происходит. <br>
                Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, 
                но возвращается результат только последнего. <br>
                Например:
                <pre class="code">

                    let a = (1 + 2, 3 + 4);

                    alert( a ); // 7 (результат вычисления 3 + 4)
                </pre>
                Первое выражение 1 + 2 выполняется, а результат отбрасывается. Затем идёт 3 + 4, выражение выполняется и возвращается результат. <br>
                Запятая имеет очень низкий приоритет. <br>
                Пожалуйста, обратите внимание, что оператор , имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом выше примере. <br>
                Без них в <b>a = 1 + 2, 3 + 4</b> сначала выполнится +, суммируя числа в <b>a = 3, 7</b>, затем оператор присваивания = присвоит <b>a = 3</b>, 
                а то, что идёт дальше, будет игнорировано. Всё так же, как в <b>(a = 1 + 2), 3 + 4</b>. <br>
                Зачем нам оператор, который отбрасывает всё, кроме последнего выражения? <br>
                Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. <br>
                Например:
                <pre class="code">

                    // три операции в одной строке
                    for (a = 1, b = 3, c = a * b; a &lt; 10; a++) {
                    ...
                    }
                </pre>
                Такие трюки используются во многих JavaScript-фреймворках. Вот почему мы упоминаем их. Но обычно они не улучшают читабельность кода, 
                поэтому стоит хорошо подумать, прежде чем их использовать.
            </p>
        </div>
    </div>
    <footer style="min-height: 150px;"></footer>
    <script src="../../../bootstrap-5.1.3-dist/js/bootstrap.min.js"></script>
</body>